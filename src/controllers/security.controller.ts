/**
 * ðŸ“Š CONTRÃ”LEUR DE MONITORING DE SÃ‰CURITÃ‰ - BuyAndSale
 *
 * Endpoints pour visualiser les statistiques et Ã©vÃ©nements de sÃ©curitÃ©
 * Accessible uniquement aux super administrateurs
 */

import { Request, Response } from 'express';
import ResponseApi from '../helper/response.js';
import { getSecurityStats } from '../utils/securityMonitor.js';
import prisma from '../model/prisma.client.js';

/**
 * ðŸ“ˆ STATISTIQUES GÃ‰NÃ‰RALES DE SÃ‰CURITÃ‰
 */
export const getSecurityStatistics = async (
  req: Request,
  res: Response
): Promise<any> => {
  try {
    // Statistiques en temps rÃ©el
    const realtimeStats = getSecurityStats();

    // Statistiques de base de donnÃ©es (derniÃ¨res 24h)
    const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);

    const dbStats = await prisma.connectionLog.groupBy({
      by: ['ipAddress'],
      where: {
        createdAt: {
          gte: yesterday,
        },
      },
      _count: {
        ipAddress: true,
      },
      orderBy: {
        _count: {
          ipAddress: 'desc',
        },
      },
      take: 10,
    });

    // Connexions par heure (derniÃ¨res 24h)
    const hourlyConnections = await prisma.$queryRaw`
      SELECT 
        HOUR(createdAt) as hour,
        COUNT(*) as connections
      FROM ConnectionLog 
      WHERE createdAt >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
      GROUP BY HOUR(createdAt)
      ORDER BY hour
    `;

    const response = {
      realtime: realtimeStats,
      database: {
        topIPs: dbStats,
        hourlyActivity: hourlyConnections,
      },
      summary: {
        securityScore: calculateSecurityScore(realtimeStats),
        threatLevel: determineThreatLevel(realtimeStats),
        recommendations: generateSecurityRecommendations(realtimeStats),
      },
    };

    return ResponseApi.success(
      res,
      'Security statistics retrieved successfully',
      response
    );
  } catch (error) {
    console.error('Error fetching security statistics:', error);
    return ResponseApi.error(
      res,
      'Failed to retrieve security statistics',
      null,
      500
    );
  }
};

/**
 * ðŸ“‹ Ã‰VÃ‰NEMENTS DE SÃ‰CURITÃ‰ RÃ‰CENTS
 */
export const getRecentSecurityEvents = async (
  req: Request,
  res: Response
): Promise<any> => {
  try {
    const limit = parseInt(req.query.limit as string) || 50;
    const offset = parseInt(req.query.offset as string) || 0;

    // RÃ©cupÃ©rer les logs de sÃ©curitÃ© depuis ConnectionLog
    // (on filtre ceux qui contiennent des types d'Ã©vÃ©nements de sÃ©curitÃ©)
    const events = await prisma.connectionLog.findMany({
      where: {
        userAgent: {
          contains: '[',
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
      take: limit,
      skip: offset,
    });

    const parsedEvents = events.map((event) => {
      // Parser le userAgent pour extraire le type d'Ã©vÃ©nement
      const match = event.userAgent.match(/\[([^\]]+)\]/);
      const eventType = match ? match[1] : 'UNKNOWN';

      return {
        id: event.id,
        type: eventType,
        timestamp: event.createdAt,
        ip: event.ipAddress,
        userId: event.userId,
        userAgent: event.userAgent.replace(/\[[^\]]+\]\s*/, ''),
        severity: determineSeverityFromType(eventType),
      };
    });

    return ResponseApi.success(
      res,
      'Recent security events retrieved successfully',
      {
        events: parsedEvents,
        pagination: {
          limit,
          offset,
          total: events.length,
        },
      }
    );
  } catch (error) {
    console.error('Error fetching security events:', error);
    return ResponseApi.error(
      res,
      'Failed to retrieve security events',
      null,
      500
    );
  }
};

/**
 * ðŸŽ¯ ANALYSE D'UNE IP SPÃ‰CIFIQUE
 */
export const analyzeIP = async (req: Request, res: Response): Promise<any> => {
  try {
    const { ip } = req.params;

    if (!ip) {
      return ResponseApi.error(res, 'IP address is required', null, 400);
    }

    // Historique de cette IP
    const ipHistory = await prisma.connectionLog.findMany({
      where: {
        ipAddress: ip,
      },
      orderBy: {
        createdAt: 'desc',
      },
      take: 100,
    });

    // Analyser les patterns
    const analysis = {
      totalRequests: ipHistory.length,
      firstSeen: ipHistory[ipHistory.length - 1]?.createdAt,
      lastSeen: ipHistory[0]?.createdAt,
      uniqueUserAgents: [...new Set(ipHistory.map((h) => h.userAgent))].length,
      securityEvents: ipHistory.filter((h) => h.userAgent.includes('[')).length,
      users: [...new Set(ipHistory.map((h) => h.userId))],
      timeline: ipHistory.slice(0, 20), // 20 Ã©vÃ©nements les plus rÃ©cents
    };

    // Score de risque
    const riskScore = calculateIPRiskScore(analysis);

    return ResponseApi.success(res, 'IP analysis completed successfully', {
      ip,
      analysis,
      riskScore,
      recommendation: getRiskRecommendation(riskScore),
    });
  } catch (error) {
    console.error('Error analyzing IP:', error);
    return ResponseApi.error(res, 'Failed to analyze IP', null, 500);
  }
};

/**
 * ðŸ§® CALCUL DU SCORE DE SÃ‰CURITÃ‰
 */
function calculateSecurityScore(stats: any): number {
  let score = 100;

  // PÃ©nalitÃ©s basÃ©es sur les attaques
  score -= Math.min(stats.totalAttacks * 2, 50);
  score -= Math.min(stats.uniqueIPs * 1, 30);

  // Bonus pour l'absence d'attaques critiques
  const criticalAttacks = stats.topAttackTypes.filter(
    (t: any) => t.type === 'SQL_INJECTION' || t.type === 'XSS_ATTEMPT'
  ).length;

  if (criticalAttacks === 0) score += 10;

  return Math.max(0, Math.min(100, score));
}

/**
 * ðŸš¨ DÃ‰TERMINATION DU NIVEAU DE MENACE
 */
function determineThreatLevel(
  stats: any
): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
  if (stats.totalAttacks === 0) return 'LOW';
  if (stats.totalAttacks < 10) return 'MEDIUM';
  if (stats.totalAttacks < 50) return 'HIGH';
  return 'CRITICAL';
}

/**
 * ðŸ’¡ GÃ‰NÃ‰RATION DE RECOMMANDATIONS
 */
function generateSecurityRecommendations(stats: any): string[] {
  const recommendations = [];

  if (stats.totalAttacks > 0) {
    recommendations.push(
      'Surveiller les IPs suspectes et envisager un blocage temporaire'
    );
  }

  if (stats.uniqueIPs > 10) {
    recommendations.push(
      "ConsidÃ©rer l'activation de CAPTCHA pour les endpoints sensibles"
    );
  }

  const hasXSS = stats.topAttackTypes.some(
    (t: any) => t.type === 'XSS_ATTEMPT'
  );
  if (hasXSS) {
    recommendations.push('Renforcer la validation des entrÃ©es utilisateur');
  }

  const hasSQL = stats.topAttackTypes.some(
    (t: any) => t.type === 'SQL_INJECTION'
  );
  if (hasSQL) {
    recommendations.push('VÃ©rifier toutes les requÃªtes de base de donnÃ©es');
  }

  if (recommendations.length === 0) {
    recommendations.push(
      'Niveau de sÃ©curitÃ© satisfaisant - maintenir la vigilance'
    );
  }

  return recommendations;
}

/**
 * ðŸŽ¯ DÃ‰TERMINATION DE LA SÃ‰VÃ‰RITÃ‰
 */
function determineSeverityFromType(
  eventType: string
): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
  switch (eventType) {
    case 'SQL_INJECTION':
      return 'CRITICAL';
    case 'XSS_ATTEMPT':
    case 'NOSQL_INJECTION':
      return 'HIGH';
    case 'RATE_LIMIT_EXCEEDED':
    case 'PARAMETER_POLLUTION':
      return 'MEDIUM';
    default:
      return 'LOW';
  }
}

/**
 * ðŸŽ¯ CALCUL DU SCORE DE RISQUE IP
 */
function calculateIPRiskScore(analysis: any): number {
  let score = 0;

  // Plus de requÃªtes = plus de risque
  score += Math.min(analysis.totalRequests * 0.1, 30);

  // Ã‰vÃ©nements de sÃ©curitÃ© = risque Ã©levÃ©
  score += analysis.securityEvents * 5;

  // Multiples user agents = suspect
  if (analysis.uniqueUserAgents > 5) score += 20;

  // Multiples utilisateurs = suspect
  if (analysis.users.length > 3) score += 15;

  return Math.min(100, score);
}

/**
 * ðŸ’­ RECOMMANDATION BASÃ‰E SUR LE RISQUE
 */
function getRiskRecommendation(riskScore: number): string {
  if (riskScore < 20) return "IP normale - pas d'action requise";
  if (riskScore < 50) return 'IP suspecte - surveiller de prÃ¨s';
  if (riskScore < 80) return 'IP Ã  risque - envisager des restrictions';
  return 'IP dangereuse - blocage recommandÃ©';
}

export default {
  getSecurityStatistics,
  getRecentSecurityEvents,
  analyzeIP,
};
